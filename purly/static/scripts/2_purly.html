<div data-purly-model="root"></div>
<script type="text/JavaScript">

  String.prototype.rsplit = function(sep, maxsplit) {
    var split = this.split(sep);
    return maxsplit ? [ split.slice(0, -maxsplit).join(sep) ].concat(split.slice(-maxsplit)) : split;
  }

  $(document).ready(function() {
    let models;
    let toSend = [];
    // inject the url for the socket.
    // via python string formatting.
    let uri = {{uri}};
    uri = uri.rsplit('/', 1)[0] + "/stream";
    let socket = new WebSocket(uri);

    socket.onmessage = function onFirstMessage(event) {
      messages = JSON.parse(event.data);
      if (messages) {
        models = messages[0].content;
        if (models.root) {
          handleUpdate({root: models.root});
        }
        messages.shift();
        handleMessages(messages)
      }
      socket.onmessage = onMessage;
      socket.send('[]');
    };

    function onMessage(event) {
      handleMessages(JSON.parse(event.data));
      let msg = [];
      while (toSend.length) {
        msg.push(toSend.shift());
      }
      socket.send(JSON.stringify(msg));
    }

    function handleMessages(messages) {
      messages.forEach(msg => {
        if (msg.header.type == 'update') {
          mergeDeepDifference(models, msg.content);
          handleUpdate(msg.content);
        }
      });
    }

    function handleUpdate(update) {
      Object.keys(update).forEach(key => {
        let selection = $('[data-purly-model=' + key + ']');
        Array.from(selection).forEach(element => {
          if (update[key]) {
            if (update[key].children) {
              registerChildren(element, update[key].children);
            } else if (update[key].attributes) {
              registerAttributes(element, update[key].attributes);
            } else if (update[key].events) {
              registerEvents(element, update[key].events);
            }
          } else {
            registerChildren(element, []);
          }
        });
      })
    }

    function registerChildren(parent, children) {
      let length = parent.children.length;
      for (let i = children.length; i < length; i++) {
        parent.removeChild(parent.lastChild);
      }
      children.forEach((spec, index) => {
        let created;
        if (spec.type == 'ref') {
          if (models[spec.ref]) {
            created = elementFromModel(models[spec.ref]);
          }
        } else {
          // the child is a string
          created = document.createTextNode(spec.str);
        }
        let current = parent.childNodes[index];
        if (current) {
          if (typeof morphdom == 'undefined') {
            parent.insertBefore(created, current);
            parent.removeChild(current);
          } else {
            // TODO: No morphdom defined in notebook in binder?
            morphdom(current, created)
          }
        } else if (created) {
          parent.appendChild(created);
        }
      })
    }

    function registerEvents(element, events) {
      let model = element.getAttribute('data-purly-model');
      Object.keys(events).forEach(type => {
        let uses = events[type];
        $(element).unbind(type);
        $(element).on(type, e => {
          let data = new Object();
          uses.forEach(key => {
            data[key] = e[key];
          })
          sendEvent(model, type, data);
        })
      })
    }

    function registerAttributes(element, attributes) {
      Object.keys(attributes).forEach(key => {
        let value = attributes[key];
        if (value != null) {
          element.setAttribute(key, value);
        } else {
          element.removeAttribute(key, value);
        }
      })
    }

    function elementFromModel(model) {
      let element = document.createElement(model.tag);
      let model_id = model.attributes['data-purly-model'];
      registerAttributes(element, model.attributes);
      registerChildren(element, model.children ? model.children : []);
      registerEvents(element, model.events);
      $(element).on('change', function(event) {
        sendUpdate(model_id, {'attributes': {'value': element.value}});
      });
      return element;
    }

    function sendEvent(model, type, data) {
      toSend.push({
        header: {
          type: 'signal'
        },
        content: {
          [model]: {
            'type': type,
            [type]: data
          }
        }
      });
    }

    function sendUpdate(model, content) {
      content = {[model]: content};
      let diff = mergeDeepDifference(models, content);
      if (diff) {
        toSend.push({
          header: {
            type: 'update'
          },
          content: diff
        });
      }
    }
  });

  function isObject(item) {
    return (item && typeof item === 'object' && !Array.isArray(item));
  }

  function mergeDeepDifference(target, source, difference) {
    if (difference == undefined) {
      difference = {};
    }
    if (isObject(target) && isObject(source)) {
      for (const key in source) {
        if (isObject(source[key])) {
          if (!target[key]) {
            Object.assign(target, { [key]: {} });
            Object.assign(difference, { [key]: {} })
          }
          difference[key] = mergeDeepDifference(target[key], source[key]);
        } else if (source[key] != null){
          if (source[key] != target[key]) {
            Object.assign(target, { [key]: source[key] });
            Object.assign(difference, { [key]: source[key] })
          }
        } else {
          delete target[key]
        }
      }
    }
    return difference
  }

</script>
