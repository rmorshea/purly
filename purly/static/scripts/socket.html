<script type="text/JavaScript">
  $(document).ready(function() {
    let models;
    let toSend = [];
    // inject the url for the socket.
    // via python string formatting.
    let socket = new WebSocket({{uri}});

    socket.onmessage = function onFirstMessage(event) {
      models = JSON.parse(event.data);
      if (models.root) {
        handleUpdate({root: models.root});
      }
      socket.onmessage = onMessage;
    }

    function onMessage(event) {
      JSON.parse(event.data).forEach(update => {
        if (update.type == 'model') {
          mergeDeep(models, update.model);
          handleUpdate(update.model);
        }
      });
      let msg = [];
      while (toSend.length) {
        msg.push(toSend.shift());
      }
      socket.send(JSON.stringify(msg));
    }

    function handleUpdate(update) {
      Object.keys(update).forEach(key => {
        let selection = $('[data-purly-model=' + key + ']');
        Array.from(selection).forEach(element => {
          if (update[key]) {
            if (update[key].children) {
              registerChildren(element, update[key].children);
            } else if (update[key].attributes) {
              registerAttributes(element, update[key].attributes);
            } else if (update[key].events) {
              registerEvents(element, update[key].events);
            }
          } else {
            registerChildren(element, []);
          }
        });
      })
    }

    function registerChildren(parent, children) {
      let length = parent.children.length;
      for (let i = children.length; i < length; i++) {
        parent.removeChild(parent.lastChild);
      }
      children.forEach((spec, index) => {
        let created;
        if (spec.type == 'ref') {
          if (models[spec.ref]) {
            created = elementFromModel(models[spec.ref]);
          }
        } else {
          // the child is a string
          created = document.createTextNode(spec.str);
        }
        let current = parent.childNodes[index];
        if (current) {
          if (typeof morphdom == 'undefined') {
            parent.insertBefore(created, current);
            parent.removeChild(current);
          } else {
            // TODO: No morphdom defined in notebook in binder?
            morphdom(current, created)
          }
        } else if (created) {
          parent.appendChild(created);
        }
      })
    }

    function registerEvents(element, events) {
      let model = element.getAttribute('data-purly-model');
      Object.keys(events).forEach(type => {
        let uses = events[type];
        $(element).unbind(type);
        $(element).on(type, e => {
          let data = new Object();
          uses.forEach(key => {
            data[key] = e[key];
          })
          toSend.push(formEvent(model, type, data));
        })
      })
    }

    function registerAttributes(element, attributes) {
      Object.keys(attributes).forEach(key => {
        let value = attributes[key];
        if (value != null) {
          element.setAttribute(key, value);
        } else {
          element.removeAttribute(key, value);
        }
      })
    }

    function elementFromModel(model) {
      let element = document.createElement(model.tag);
      registerAttributes(element, model.attributes);
      registerChildren(element, model.children ? model.children : []);
      registerEvents(element, model.events)
      return element;
    }
  });

  function formEvent(model, type, data) {
    return {
      type: 'event',
      'event': {
        [model]: {
          'type': type,
          [type]: data
        }
      }
    };
  }

  function isObject(item) {
    return (item && typeof item === 'object' && !Array.isArray(item));
  }

  function mergeDeep(target, source) {
    if (isObject(target) && isObject(source)) {
      for (const key in source) {
        if (isObject(source[key])) {
          if (!target[key]) Object.assign(target, { [key]: {} });
          mergeDeep(target[key], source[key]);
        } else if (source[key] != null){
          Object.assign(target, { [key]: source[key] });
        } else {
          delete target[key]
        }
      }
    }
    return target
  }
</script>
